Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    TRUE
    COMMENT
    FALSE

Grammar

Rule 0     S' -> program
Rule 1     program -> more_vars more_func main
Rule 2     more_vars -> vars
Rule 3     more_vars -> <empty>
Rule 4     vars -> var_type vars_aux SEMICOLON more_vars
Rule 5     var_type -> BOOL
Rule 6     var_type -> INT
Rule 7     var_type -> DOUBLE
Rule 8     vars_aux -> ID arr to_var_table var_assign more_vars_aux
Rule 9     to_var_table -> <empty>
Rule 10    var_assign -> EQUALS var_cte
Rule 11    var_assign -> <empty>
Rule 12    more_vars_aux -> COMMA vars_aux
Rule 13    more_vars_aux -> <empty>
Rule 14    arr -> LSQRTBRACKET const RSQRTBRACKET arr
Rule 15    arr -> <empty>
Rule 16    var_cte -> CTEINT
Rule 17    var_cte -> CTEDOUBLE
Rule 18    var_cte -> CTEBOOL
Rule 19    var_cte -> ID arr
Rule 20    var_cte -> func_call
Rule 21    const -> CTEINT
Rule 22    const -> CTEDOUBLE
Rule 23    const -> CTEBOOL
Rule 24    more_func -> func
Rule 25    more_func -> <empty>
Rule 26    func -> FUNC func_type ID to_proc_dir LPAR arguments RPAR func_block more_func
Rule 27    to_proc_dir -> <empty>
Rule 28    func_type -> VOID
Rule 29    func_type -> BOOL
Rule 30    func_type -> INT
Rule 31    func_type -> DOUBLE
Rule 32    arguments -> var_type ID to_args more_args
Rule 33    arguments -> <empty>
Rule 34    more_args -> COMMA var_type ID to_args more_args
Rule 35    more_args -> <empty>
Rule 36    to_args -> <empty>
Rule 37    func_block -> LBRACKET more_vars more_statement optional_return RBRACKET
Rule 38    optional_return -> RETURN exp SEMICOLON
Rule 39    optional_return -> <empty>
Rule 40    more_statement -> statement more_statement
Rule 41    more_statement -> <empty>
Rule 42    statement -> read
Rule 43    statement -> write
Rule 44    statement -> cicle
Rule 45    statement -> condition
Rule 46    statement -> assignation
Rule 47    statement -> func_call SEMICOLON
Rule 48    read -> READ LPAR ID arr_par RPAR SEMICOLON
Rule 49    write -> WRITE LPAR exp RPAR SEMICOLON
Rule 50    cicle -> WHILE LPAR expression RPAR block
Rule 51    condition -> IF LPAR expression RPAR block else_posible
Rule 52    else_posible -> ELSE block
Rule 53    else_posible -> <empty>
Rule 54    assignation -> ID arr_par EQUALS assign SEMICOLON
Rule 55    assign -> expression
Rule 56    assign -> func_call
Rule 57    func_call -> ID LPAR params RPAR
Rule 58    params -> exp more_params
Rule 59    params -> <empty>
Rule 60    more_params -> COMMA exp more_params
Rule 61    more_params -> <empty>
Rule 62    block -> LBRACKET more_statement RBRACKET
Rule 63    arr_par -> LSQRTBRACKET exp RSQRTBRACKET arr_par
Rule 64    arr_par -> <empty>
Rule 65    expression -> conc expression_aux
Rule 66    expression_aux -> ao conc expression_aux
Rule 67    expression_aux -> <empty>
Rule 68    conc -> exp conc_aux
Rule 69    conc_aux -> comp exp
Rule 70    conc_aux -> <empty>
Rule 71    exp -> term exp_aux
Rule 72    exp_aux -> pl term exp_aux
Rule 73    exp_aux -> <empty>
Rule 74    term -> factor term_aux
Rule 75    term_aux -> dm factor term_aux
Rule 76    term_aux -> <empty>
Rule 77    factor -> LPAR expression RPAR
Rule 78    factor -> var_cte
Rule 79    ao -> AND
Rule 80    ao -> OR
Rule 81    comp -> GREATER
Rule 82    comp -> LESS
Rule 83    comp -> GREATEROREQUAL
Rule 84    comp -> LESSOREQUAL
Rule 85    comp -> EQUALEQUALS
Rule 86    comp -> DIFFERENT
Rule 87    pl -> PLUS
Rule 88    pl -> MINUS
Rule 89    dm -> MULTIPLICATION
Rule 90    dm -> DIVISION
Rule 91    dm -> MOD
Rule 92    main -> MAIN main_block
Rule 93    main_block -> LBRACKET more_vars more_statement RBRACKET

Terminals, with rules where they appear

AND                  : 79
BOOL                 : 5 29
COMMA                : 12 34 60
COMMENT              : 
CTEBOOL              : 18 23
CTEDOUBLE            : 17 22
CTEINT               : 16 21
DIFFERENT            : 86
DIVISION             : 90
DOUBLE               : 7 31
ELSE                 : 52
EQUALEQUALS          : 85
EQUALS               : 10 54
FALSE                : 
FUNC                 : 26
GREATER              : 81
GREATEROREQUAL       : 83
ID                   : 8 19 26 32 34 48 54 57
IF                   : 51
INT                  : 6 30
LBRACKET             : 37 62 93
LESS                 : 82
LESSOREQUAL          : 84
LPAR                 : 26 48 49 50 51 57 77
LSQRTBRACKET         : 14 63
MAIN                 : 92
MINUS                : 88
MOD                  : 91
MULTIPLICATION       : 89
OR                   : 80
PLUS                 : 87
RBRACKET             : 37 62 93
READ                 : 48
RETURN               : 38
RPAR                 : 26 48 49 50 51 57 77
RSQRTBRACKET         : 14 63
SEMICOLON            : 4 38 47 48 49 54
TRUE                 : 
VOID                 : 28
WHILE                : 50
WRITE                : 49
error                : 

Nonterminals, with rules where they appear

ao                   : 66
arguments            : 26
arr                  : 8 14 19
arr_par              : 48 54 63
assign               : 54
assignation          : 46
block                : 50 51 52
cicle                : 44
comp                 : 69
conc                 : 65 66
conc_aux             : 68
condition            : 45
const                : 14
dm                   : 75
else_posible         : 51
exp                  : 38 49 58 60 63 68 69
exp_aux              : 71 72
expression           : 50 51 55 77
expression_aux       : 65 66
factor               : 74 75
func                 : 24
func_block           : 26
func_call            : 20 47 56
func_type            : 26
main                 : 1
main_block           : 92
more_args            : 32 34
more_func            : 1 26
more_params          : 58 60
more_statement       : 37 40 62 93
more_vars            : 1 4 37 93
more_vars_aux        : 8
optional_return      : 37
params               : 57
pl                   : 72
program              : 0
read                 : 42
statement            : 40
term                 : 71 72
term_aux             : 74 75
to_args              : 32 34
to_proc_dir          : 26
to_var_table         : 8
var_assign           : 8
var_cte              : 10 78
var_type             : 4 32 34
vars                 : 2
vars_aux             : 4 12
write                : 43

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . more_vars more_func main
    (2) more_vars -> . vars
    (3) more_vars -> .
    (4) vars -> . var_type vars_aux SEMICOLON more_vars
    (5) var_type -> . BOOL
    (6) var_type -> . INT
    (7) var_type -> . DOUBLE

    FUNC            reduce using rule 3 (more_vars -> .)
    MAIN            reduce using rule 3 (more_vars -> .)
    BOOL            shift and go to state 6
    INT             shift and go to state 3
    DOUBLE          shift and go to state 4

    vars                           shift and go to state 1
    var_type                       shift and go to state 2
    program                        shift and go to state 5
    more_vars                      shift and go to state 7

state 1

    (2) more_vars -> vars .

    READ            reduce using rule 2 (more_vars -> vars .)
    WRITE           reduce using rule 2 (more_vars -> vars .)
    WHILE           reduce using rule 2 (more_vars -> vars .)
    IF              reduce using rule 2 (more_vars -> vars .)
    ID              reduce using rule 2 (more_vars -> vars .)
    RETURN          reduce using rule 2 (more_vars -> vars .)
    RBRACKET        reduce using rule 2 (more_vars -> vars .)
    FUNC            reduce using rule 2 (more_vars -> vars .)
    MAIN            reduce using rule 2 (more_vars -> vars .)


state 2

    (4) vars -> var_type . vars_aux SEMICOLON more_vars
    (8) vars_aux -> . ID arr to_var_table var_assign more_vars_aux

    ID              shift and go to state 9

    vars_aux                       shift and go to state 8

state 3

    (6) var_type -> INT .

    ID              reduce using rule 6 (var_type -> INT .)


state 4

    (7) var_type -> DOUBLE .

    ID              reduce using rule 7 (var_type -> DOUBLE .)


state 5

    (0) S' -> program .



state 6

    (5) var_type -> BOOL .

    ID              reduce using rule 5 (var_type -> BOOL .)


state 7

    (1) program -> more_vars . more_func main
    (24) more_func -> . func
    (25) more_func -> .
    (26) func -> . FUNC func_type ID to_proc_dir LPAR arguments RPAR func_block more_func

    MAIN            reduce using rule 25 (more_func -> .)
    FUNC            shift and go to state 12

    more_func                      shift and go to state 11
    func                           shift and go to state 10

state 8

    (4) vars -> var_type vars_aux . SEMICOLON more_vars

    SEMICOLON       shift and go to state 13


state 9

    (8) vars_aux -> ID . arr to_var_table var_assign more_vars_aux
    (14) arr -> . LSQRTBRACKET const RSQRTBRACKET arr
    (15) arr -> .

    LSQRTBRACKET    shift and go to state 15
    EQUALS          reduce using rule 15 (arr -> .)
    COMMA           reduce using rule 15 (arr -> .)
    SEMICOLON       reduce using rule 15 (arr -> .)

    arr                            shift and go to state 14

state 10

    (24) more_func -> func .

    MAIN            reduce using rule 24 (more_func -> func .)


state 11

    (1) program -> more_vars more_func . main
    (92) main -> . MAIN main_block

    MAIN            shift and go to state 16

    main                           shift and go to state 17

state 12

    (26) func -> FUNC . func_type ID to_proc_dir LPAR arguments RPAR func_block more_func
    (28) func_type -> . VOID
    (29) func_type -> . BOOL
    (30) func_type -> . INT
    (31) func_type -> . DOUBLE

    VOID            shift and go to state 20
    BOOL            shift and go to state 22
    INT             shift and go to state 21
    DOUBLE          shift and go to state 19

    func_type                      shift and go to state 18

state 13

    (4) vars -> var_type vars_aux SEMICOLON . more_vars
    (2) more_vars -> . vars
    (3) more_vars -> .
    (4) vars -> . var_type vars_aux SEMICOLON more_vars
    (5) var_type -> . BOOL
    (6) var_type -> . INT
    (7) var_type -> . DOUBLE

    FUNC            reduce using rule 3 (more_vars -> .)
    MAIN            reduce using rule 3 (more_vars -> .)
    READ            reduce using rule 3 (more_vars -> .)
    WRITE           reduce using rule 3 (more_vars -> .)
    WHILE           reduce using rule 3 (more_vars -> .)
    IF              reduce using rule 3 (more_vars -> .)
    ID              reduce using rule 3 (more_vars -> .)
    RBRACKET        reduce using rule 3 (more_vars -> .)
    RETURN          reduce using rule 3 (more_vars -> .)
    BOOL            shift and go to state 6
    INT             shift and go to state 3
    DOUBLE          shift and go to state 4

    vars                           shift and go to state 1
    more_vars                      shift and go to state 23
    var_type                       shift and go to state 2

state 14

    (8) vars_aux -> ID arr . to_var_table var_assign more_vars_aux
    (9) to_var_table -> .

    EQUALS          reduce using rule 9 (to_var_table -> .)
    COMMA           reduce using rule 9 (to_var_table -> .)
    SEMICOLON       reduce using rule 9 (to_var_table -> .)

    to_var_table                   shift and go to state 24

state 15

    (14) arr -> LSQRTBRACKET . const RSQRTBRACKET arr
    (21) const -> . CTEINT
    (22) const -> . CTEDOUBLE
    (23) const -> . CTEBOOL

    CTEINT          shift and go to state 28
    CTEDOUBLE       shift and go to state 25
    CTEBOOL         shift and go to state 27

    const                          shift and go to state 26

state 16

    (92) main -> MAIN . main_block
    (93) main_block -> . LBRACKET more_vars more_statement RBRACKET

    LBRACKET        shift and go to state 30

    main_block                     shift and go to state 29

state 17

    (1) program -> more_vars more_func main .

    $end            reduce using rule 1 (program -> more_vars more_func main .)


state 18

    (26) func -> FUNC func_type . ID to_proc_dir LPAR arguments RPAR func_block more_func

    ID              shift and go to state 31


state 19

    (31) func_type -> DOUBLE .

    ID              reduce using rule 31 (func_type -> DOUBLE .)


state 20

    (28) func_type -> VOID .

    ID              reduce using rule 28 (func_type -> VOID .)


state 21

    (30) func_type -> INT .

    ID              reduce using rule 30 (func_type -> INT .)


state 22

    (29) func_type -> BOOL .

    ID              reduce using rule 29 (func_type -> BOOL .)


state 23

    (4) vars -> var_type vars_aux SEMICOLON more_vars .

    READ            reduce using rule 4 (vars -> var_type vars_aux SEMICOLON more_vars .)
    WRITE           reduce using rule 4 (vars -> var_type vars_aux SEMICOLON more_vars .)
    WHILE           reduce using rule 4 (vars -> var_type vars_aux SEMICOLON more_vars .)
    IF              reduce using rule 4 (vars -> var_type vars_aux SEMICOLON more_vars .)
    ID              reduce using rule 4 (vars -> var_type vars_aux SEMICOLON more_vars .)
    RETURN          reduce using rule 4 (vars -> var_type vars_aux SEMICOLON more_vars .)
    RBRACKET        reduce using rule 4 (vars -> var_type vars_aux SEMICOLON more_vars .)
    FUNC            reduce using rule 4 (vars -> var_type vars_aux SEMICOLON more_vars .)
    MAIN            reduce using rule 4 (vars -> var_type vars_aux SEMICOLON more_vars .)


state 24

    (8) vars_aux -> ID arr to_var_table . var_assign more_vars_aux
    (10) var_assign -> . EQUALS var_cte
    (11) var_assign -> .

    EQUALS          shift and go to state 32
    COMMA           reduce using rule 11 (var_assign -> .)
    SEMICOLON       reduce using rule 11 (var_assign -> .)

    var_assign                     shift and go to state 33

state 25

    (22) const -> CTEDOUBLE .

    RSQRTBRACKET    reduce using rule 22 (const -> CTEDOUBLE .)


state 26

    (14) arr -> LSQRTBRACKET const . RSQRTBRACKET arr

    RSQRTBRACKET    shift and go to state 34


state 27

    (23) const -> CTEBOOL .

    RSQRTBRACKET    reduce using rule 23 (const -> CTEBOOL .)


state 28

    (21) const -> CTEINT .

    RSQRTBRACKET    reduce using rule 21 (const -> CTEINT .)


state 29

    (92) main -> MAIN main_block .

    $end            reduce using rule 92 (main -> MAIN main_block .)


state 30

    (93) main_block -> LBRACKET . more_vars more_statement RBRACKET
    (2) more_vars -> . vars
    (3) more_vars -> .
    (4) vars -> . var_type vars_aux SEMICOLON more_vars
    (5) var_type -> . BOOL
    (6) var_type -> . INT
    (7) var_type -> . DOUBLE

    READ            reduce using rule 3 (more_vars -> .)
    WRITE           reduce using rule 3 (more_vars -> .)
    WHILE           reduce using rule 3 (more_vars -> .)
    IF              reduce using rule 3 (more_vars -> .)
    ID              reduce using rule 3 (more_vars -> .)
    RBRACKET        reduce using rule 3 (more_vars -> .)
    BOOL            shift and go to state 6
    INT             shift and go to state 3
    DOUBLE          shift and go to state 4

    var_type                       shift and go to state 2
    more_vars                      shift and go to state 35
    vars                           shift and go to state 1

state 31

    (26) func -> FUNC func_type ID . to_proc_dir LPAR arguments RPAR func_block more_func
    (27) to_proc_dir -> .

    LPAR            reduce using rule 27 (to_proc_dir -> .)

    to_proc_dir                    shift and go to state 36

state 32

    (10) var_assign -> EQUALS . var_cte
    (16) var_cte -> . CTEINT
    (17) var_cte -> . CTEDOUBLE
    (18) var_cte -> . CTEBOOL
    (19) var_cte -> . ID arr
    (20) var_cte -> . func_call
    (57) func_call -> . ID LPAR params RPAR

    CTEINT          shift and go to state 40
    CTEDOUBLE       shift and go to state 37
    CTEBOOL         shift and go to state 39
    ID              shift and go to state 42

    func_call                      shift and go to state 38
    var_cte                        shift and go to state 41

state 33

    (8) vars_aux -> ID arr to_var_table var_assign . more_vars_aux
    (12) more_vars_aux -> . COMMA vars_aux
    (13) more_vars_aux -> .

    COMMA           shift and go to state 44
    SEMICOLON       reduce using rule 13 (more_vars_aux -> .)

    more_vars_aux                  shift and go to state 43

state 34

    (14) arr -> LSQRTBRACKET const RSQRTBRACKET . arr
    (14) arr -> . LSQRTBRACKET const RSQRTBRACKET arr
    (15) arr -> .

    LSQRTBRACKET    shift and go to state 15
    EQUALS          reduce using rule 15 (arr -> .)
    COMMA           reduce using rule 15 (arr -> .)
    SEMICOLON       reduce using rule 15 (arr -> .)
    MULTIPLICATION  reduce using rule 15 (arr -> .)
    DIVISION        reduce using rule 15 (arr -> .)
    MOD             reduce using rule 15 (arr -> .)
    PLUS            reduce using rule 15 (arr -> .)
    MINUS           reduce using rule 15 (arr -> .)
    RPAR            reduce using rule 15 (arr -> .)
    GREATER         reduce using rule 15 (arr -> .)
    LESS            reduce using rule 15 (arr -> .)
    GREATEROREQUAL  reduce using rule 15 (arr -> .)
    LESSOREQUAL     reduce using rule 15 (arr -> .)
    EQUALEQUALS     reduce using rule 15 (arr -> .)
    DIFFERENT       reduce using rule 15 (arr -> .)
    AND             reduce using rule 15 (arr -> .)
    OR              reduce using rule 15 (arr -> .)
    RSQRTBRACKET    reduce using rule 15 (arr -> .)

    arr                            shift and go to state 45

state 35

    (93) main_block -> LBRACKET more_vars . more_statement RBRACKET
    (40) more_statement -> . statement more_statement
    (41) more_statement -> .
    (42) statement -> . read
    (43) statement -> . write
    (44) statement -> . cicle
    (45) statement -> . condition
    (46) statement -> . assignation
    (47) statement -> . func_call SEMICOLON
    (48) read -> . READ LPAR ID arr_par RPAR SEMICOLON
    (49) write -> . WRITE LPAR exp RPAR SEMICOLON
    (50) cicle -> . WHILE LPAR expression RPAR block
    (51) condition -> . IF LPAR expression RPAR block else_posible
    (54) assignation -> . ID arr_par EQUALS assign SEMICOLON
    (57) func_call -> . ID LPAR params RPAR

    RBRACKET        reduce using rule 41 (more_statement -> .)
    READ            shift and go to state 46
    WRITE           shift and go to state 52
    WHILE           shift and go to state 47
    IF              shift and go to state 55
    ID              shift and go to state 53

    func_call                      shift and go to state 56
    assignation                    shift and go to state 57
    read                           shift and go to state 51
    cicle                          shift and go to state 48
    write                          shift and go to state 49
    statement                      shift and go to state 50
    more_statement                 shift and go to state 58
    condition                      shift and go to state 54

state 36

    (26) func -> FUNC func_type ID to_proc_dir . LPAR arguments RPAR func_block more_func

    LPAR            shift and go to state 59


state 37

    (17) var_cte -> CTEDOUBLE .

    MULTIPLICATION  reduce using rule 17 (var_cte -> CTEDOUBLE .)
    DIVISION        reduce using rule 17 (var_cte -> CTEDOUBLE .)
    MOD             reduce using rule 17 (var_cte -> CTEDOUBLE .)
    PLUS            reduce using rule 17 (var_cte -> CTEDOUBLE .)
    MINUS           reduce using rule 17 (var_cte -> CTEDOUBLE .)
    RPAR            reduce using rule 17 (var_cte -> CTEDOUBLE .)
    COMMA           reduce using rule 17 (var_cte -> CTEDOUBLE .)
    SEMICOLON       reduce using rule 17 (var_cte -> CTEDOUBLE .)
    GREATER         reduce using rule 17 (var_cte -> CTEDOUBLE .)
    LESS            reduce using rule 17 (var_cte -> CTEDOUBLE .)
    GREATEROREQUAL  reduce using rule 17 (var_cte -> CTEDOUBLE .)
    LESSOREQUAL     reduce using rule 17 (var_cte -> CTEDOUBLE .)
    EQUALEQUALS     reduce using rule 17 (var_cte -> CTEDOUBLE .)
    DIFFERENT       reduce using rule 17 (var_cte -> CTEDOUBLE .)
    AND             reduce using rule 17 (var_cte -> CTEDOUBLE .)
    OR              reduce using rule 17 (var_cte -> CTEDOUBLE .)
    RSQRTBRACKET    reduce using rule 17 (var_cte -> CTEDOUBLE .)


state 38

    (20) var_cte -> func_call .

    MULTIPLICATION  reduce using rule 20 (var_cte -> func_call .)
    DIVISION        reduce using rule 20 (var_cte -> func_call .)
    MOD             reduce using rule 20 (var_cte -> func_call .)
    PLUS            reduce using rule 20 (var_cte -> func_call .)
    MINUS           reduce using rule 20 (var_cte -> func_call .)
    RPAR            reduce using rule 20 (var_cte -> func_call .)
    COMMA           reduce using rule 20 (var_cte -> func_call .)
    SEMICOLON       reduce using rule 20 (var_cte -> func_call .)
    GREATER         reduce using rule 20 (var_cte -> func_call .)
    LESS            reduce using rule 20 (var_cte -> func_call .)
    GREATEROREQUAL  reduce using rule 20 (var_cte -> func_call .)
    LESSOREQUAL     reduce using rule 20 (var_cte -> func_call .)
    EQUALEQUALS     reduce using rule 20 (var_cte -> func_call .)
    DIFFERENT       reduce using rule 20 (var_cte -> func_call .)
    AND             reduce using rule 20 (var_cte -> func_call .)
    OR              reduce using rule 20 (var_cte -> func_call .)
    RSQRTBRACKET    reduce using rule 20 (var_cte -> func_call .)


state 39

    (18) var_cte -> CTEBOOL .

    MULTIPLICATION  reduce using rule 18 (var_cte -> CTEBOOL .)
    DIVISION        reduce using rule 18 (var_cte -> CTEBOOL .)
    MOD             reduce using rule 18 (var_cte -> CTEBOOL .)
    PLUS            reduce using rule 18 (var_cte -> CTEBOOL .)
    MINUS           reduce using rule 18 (var_cte -> CTEBOOL .)
    RPAR            reduce using rule 18 (var_cte -> CTEBOOL .)
    COMMA           reduce using rule 18 (var_cte -> CTEBOOL .)
    SEMICOLON       reduce using rule 18 (var_cte -> CTEBOOL .)
    GREATER         reduce using rule 18 (var_cte -> CTEBOOL .)
    LESS            reduce using rule 18 (var_cte -> CTEBOOL .)
    GREATEROREQUAL  reduce using rule 18 (var_cte -> CTEBOOL .)
    LESSOREQUAL     reduce using rule 18 (var_cte -> CTEBOOL .)
    EQUALEQUALS     reduce using rule 18 (var_cte -> CTEBOOL .)
    DIFFERENT       reduce using rule 18 (var_cte -> CTEBOOL .)
    AND             reduce using rule 18 (var_cte -> CTEBOOL .)
    OR              reduce using rule 18 (var_cte -> CTEBOOL .)
    RSQRTBRACKET    reduce using rule 18 (var_cte -> CTEBOOL .)


state 40

    (16) var_cte -> CTEINT .

    MULTIPLICATION  reduce using rule 16 (var_cte -> CTEINT .)
    DIVISION        reduce using rule 16 (var_cte -> CTEINT .)
    MOD             reduce using rule 16 (var_cte -> CTEINT .)
    PLUS            reduce using rule 16 (var_cte -> CTEINT .)
    MINUS           reduce using rule 16 (var_cte -> CTEINT .)
    RPAR            reduce using rule 16 (var_cte -> CTEINT .)
    COMMA           reduce using rule 16 (var_cte -> CTEINT .)
    SEMICOLON       reduce using rule 16 (var_cte -> CTEINT .)
    GREATER         reduce using rule 16 (var_cte -> CTEINT .)
    LESS            reduce using rule 16 (var_cte -> CTEINT .)
    GREATEROREQUAL  reduce using rule 16 (var_cte -> CTEINT .)
    LESSOREQUAL     reduce using rule 16 (var_cte -> CTEINT .)
    EQUALEQUALS     reduce using rule 16 (var_cte -> CTEINT .)
    DIFFERENT       reduce using rule 16 (var_cte -> CTEINT .)
    AND             reduce using rule 16 (var_cte -> CTEINT .)
    OR              reduce using rule 16 (var_cte -> CTEINT .)
    RSQRTBRACKET    reduce using rule 16 (var_cte -> CTEINT .)


state 41

    (10) var_assign -> EQUALS var_cte .

    COMMA           reduce using rule 10 (var_assign -> EQUALS var_cte .)
    SEMICOLON       reduce using rule 10 (var_assign -> EQUALS var_cte .)


state 42

    (19) var_cte -> ID . arr
    (57) func_call -> ID . LPAR params RPAR
    (14) arr -> . LSQRTBRACKET const RSQRTBRACKET arr
    (15) arr -> .

    LPAR            shift and go to state 60
    LSQRTBRACKET    shift and go to state 15
    COMMA           reduce using rule 15 (arr -> .)
    SEMICOLON       reduce using rule 15 (arr -> .)
    MULTIPLICATION  reduce using rule 15 (arr -> .)
    DIVISION        reduce using rule 15 (arr -> .)
    MOD             reduce using rule 15 (arr -> .)
    PLUS            reduce using rule 15 (arr -> .)
    MINUS           reduce using rule 15 (arr -> .)
    RPAR            reduce using rule 15 (arr -> .)
    GREATER         reduce using rule 15 (arr -> .)
    LESS            reduce using rule 15 (arr -> .)
    GREATEROREQUAL  reduce using rule 15 (arr -> .)
    LESSOREQUAL     reduce using rule 15 (arr -> .)
    EQUALEQUALS     reduce using rule 15 (arr -> .)
    DIFFERENT       reduce using rule 15 (arr -> .)
    AND             reduce using rule 15 (arr -> .)
    OR              reduce using rule 15 (arr -> .)
    RSQRTBRACKET    reduce using rule 15 (arr -> .)

    arr                            shift and go to state 61

state 43

    (8) vars_aux -> ID arr to_var_table var_assign more_vars_aux .

    SEMICOLON       reduce using rule 8 (vars_aux -> ID arr to_var_table var_assign more_vars_aux .)


state 44

    (12) more_vars_aux -> COMMA . vars_aux
    (8) vars_aux -> . ID arr to_var_table var_assign more_vars_aux

    ID              shift and go to state 9

    vars_aux                       shift and go to state 62

state 45

    (14) arr -> LSQRTBRACKET const RSQRTBRACKET arr .

    MULTIPLICATION  reduce using rule 14 (arr -> LSQRTBRACKET const RSQRTBRACKET arr .)
    DIVISION        reduce using rule 14 (arr -> LSQRTBRACKET const RSQRTBRACKET arr .)
    MOD             reduce using rule 14 (arr -> LSQRTBRACKET const RSQRTBRACKET arr .)
    PLUS            reduce using rule 14 (arr -> LSQRTBRACKET const RSQRTBRACKET arr .)
    MINUS           reduce using rule 14 (arr -> LSQRTBRACKET const RSQRTBRACKET arr .)
    GREATER         reduce using rule 14 (arr -> LSQRTBRACKET const RSQRTBRACKET arr .)
    LESS            reduce using rule 14 (arr -> LSQRTBRACKET const RSQRTBRACKET arr .)
    GREATEROREQUAL  reduce using rule 14 (arr -> LSQRTBRACKET const RSQRTBRACKET arr .)
    LESSOREQUAL     reduce using rule 14 (arr -> LSQRTBRACKET const RSQRTBRACKET arr .)
    EQUALEQUALS     reduce using rule 14 (arr -> LSQRTBRACKET const RSQRTBRACKET arr .)
    DIFFERENT       reduce using rule 14 (arr -> LSQRTBRACKET const RSQRTBRACKET arr .)
    AND             reduce using rule 14 (arr -> LSQRTBRACKET const RSQRTBRACKET arr .)
    OR              reduce using rule 14 (arr -> LSQRTBRACKET const RSQRTBRACKET arr .)
    SEMICOLON       reduce using rule 14 (arr -> LSQRTBRACKET const RSQRTBRACKET arr .)
    EQUALS          reduce using rule 14 (arr -> LSQRTBRACKET const RSQRTBRACKET arr .)
    COMMA           reduce using rule 14 (arr -> LSQRTBRACKET const RSQRTBRACKET arr .)
    RPAR            reduce using rule 14 (arr -> LSQRTBRACKET const RSQRTBRACKET arr .)
    RSQRTBRACKET    reduce using rule 14 (arr -> LSQRTBRACKET const RSQRTBRACKET arr .)


state 46

    (48) read -> READ . LPAR ID arr_par RPAR SEMICOLON

    LPAR            shift and go to state 63


state 47

    (50) cicle -> WHILE . LPAR expression RPAR block

    LPAR            shift and go to state 64


state 48

    (44) statement -> cicle .

    READ            reduce using rule 44 (statement -> cicle .)
    WRITE           reduce using rule 44 (statement -> cicle .)
    WHILE           reduce using rule 44 (statement -> cicle .)
    IF              reduce using rule 44 (statement -> cicle .)
    ID              reduce using rule 44 (statement -> cicle .)
    RETURN          reduce using rule 44 (statement -> cicle .)
    RBRACKET        reduce using rule 44 (statement -> cicle .)


state 49

    (43) statement -> write .

    READ            reduce using rule 43 (statement -> write .)
    WRITE           reduce using rule 43 (statement -> write .)
    WHILE           reduce using rule 43 (statement -> write .)
    IF              reduce using rule 43 (statement -> write .)
    ID              reduce using rule 43 (statement -> write .)
    RETURN          reduce using rule 43 (statement -> write .)
    RBRACKET        reduce using rule 43 (statement -> write .)


state 50

    (40) more_statement -> statement . more_statement
    (40) more_statement -> . statement more_statement
    (41) more_statement -> .
    (42) statement -> . read
    (43) statement -> . write
    (44) statement -> . cicle
    (45) statement -> . condition
    (46) statement -> . assignation
    (47) statement -> . func_call SEMICOLON
    (48) read -> . READ LPAR ID arr_par RPAR SEMICOLON
    (49) write -> . WRITE LPAR exp RPAR SEMICOLON
    (50) cicle -> . WHILE LPAR expression RPAR block
    (51) condition -> . IF LPAR expression RPAR block else_posible
    (54) assignation -> . ID arr_par EQUALS assign SEMICOLON
    (57) func_call -> . ID LPAR params RPAR

    RBRACKET        reduce using rule 41 (more_statement -> .)
    RETURN          reduce using rule 41 (more_statement -> .)
    READ            shift and go to state 46
    WRITE           shift and go to state 52
    WHILE           shift and go to state 47
    IF              shift and go to state 55
    ID              shift and go to state 53

    func_call                      shift and go to state 56
    assignation                    shift and go to state 57
    read                           shift and go to state 51
    cicle                          shift and go to state 48
    write                          shift and go to state 49
    statement                      shift and go to state 50
    more_statement                 shift and go to state 65
    condition                      shift and go to state 54

state 51

    (42) statement -> read .

    READ            reduce using rule 42 (statement -> read .)
    WRITE           reduce using rule 42 (statement -> read .)
    WHILE           reduce using rule 42 (statement -> read .)
    IF              reduce using rule 42 (statement -> read .)
    ID              reduce using rule 42 (statement -> read .)
    RETURN          reduce using rule 42 (statement -> read .)
    RBRACKET        reduce using rule 42 (statement -> read .)


state 52

    (49) write -> WRITE . LPAR exp RPAR SEMICOLON

    LPAR            shift and go to state 66


state 53

    (54) assignation -> ID . arr_par EQUALS assign SEMICOLON
    (57) func_call -> ID . LPAR params RPAR
    (63) arr_par -> . LSQRTBRACKET exp RSQRTBRACKET arr_par
    (64) arr_par -> .

    LPAR            shift and go to state 60
    LSQRTBRACKET    shift and go to state 67
    EQUALS          reduce using rule 64 (arr_par -> .)

    arr_par                        shift and go to state 68

state 54

    (45) statement -> condition .

    READ            reduce using rule 45 (statement -> condition .)
    WRITE           reduce using rule 45 (statement -> condition .)
    WHILE           reduce using rule 45 (statement -> condition .)
    IF              reduce using rule 45 (statement -> condition .)
    ID              reduce using rule 45 (statement -> condition .)
    RETURN          reduce using rule 45 (statement -> condition .)
    RBRACKET        reduce using rule 45 (statement -> condition .)


state 55

    (51) condition -> IF . LPAR expression RPAR block else_posible

    LPAR            shift and go to state 69


state 56

    (47) statement -> func_call . SEMICOLON

    SEMICOLON       shift and go to state 70


state 57

    (46) statement -> assignation .

    READ            reduce using rule 46 (statement -> assignation .)
    WRITE           reduce using rule 46 (statement -> assignation .)
    WHILE           reduce using rule 46 (statement -> assignation .)
    IF              reduce using rule 46 (statement -> assignation .)
    ID              reduce using rule 46 (statement -> assignation .)
    RETURN          reduce using rule 46 (statement -> assignation .)
    RBRACKET        reduce using rule 46 (statement -> assignation .)


state 58

    (93) main_block -> LBRACKET more_vars more_statement . RBRACKET

    RBRACKET        shift and go to state 71


state 59

    (26) func -> FUNC func_type ID to_proc_dir LPAR . arguments RPAR func_block more_func
    (32) arguments -> . var_type ID to_args more_args
    (33) arguments -> .
    (5) var_type -> . BOOL
    (6) var_type -> . INT
    (7) var_type -> . DOUBLE

    RPAR            reduce using rule 33 (arguments -> .)
    BOOL            shift and go to state 6
    INT             shift and go to state 3
    DOUBLE          shift and go to state 4

    var_type                       shift and go to state 72
    arguments                      shift and go to state 73

state 60

    (57) func_call -> ID LPAR . params RPAR
    (58) params -> . exp more_params
    (59) params -> .
    (71) exp -> . term exp_aux
    (74) term -> . factor term_aux
    (77) factor -> . LPAR expression RPAR
    (78) factor -> . var_cte
    (16) var_cte -> . CTEINT
    (17) var_cte -> . CTEDOUBLE
    (18) var_cte -> . CTEBOOL
    (19) var_cte -> . ID arr
    (20) var_cte -> . func_call
    (57) func_call -> . ID LPAR params RPAR

    RPAR            reduce using rule 59 (params -> .)
    LPAR            shift and go to state 74
    CTEINT          shift and go to state 40
    CTEDOUBLE       shift and go to state 37
    CTEBOOL         shift and go to state 39
    ID              shift and go to state 42

    func_call                      shift and go to state 38
    term                           shift and go to state 75
    var_cte                        shift and go to state 79
    params                         shift and go to state 76
    exp                            shift and go to state 77
    factor                         shift and go to state 78

state 61

    (19) var_cte -> ID arr .

    MULTIPLICATION  reduce using rule 19 (var_cte -> ID arr .)
    DIVISION        reduce using rule 19 (var_cte -> ID arr .)
    MOD             reduce using rule 19 (var_cte -> ID arr .)
    PLUS            reduce using rule 19 (var_cte -> ID arr .)
    MINUS           reduce using rule 19 (var_cte -> ID arr .)
    RPAR            reduce using rule 19 (var_cte -> ID arr .)
    COMMA           reduce using rule 19 (var_cte -> ID arr .)
    SEMICOLON       reduce using rule 19 (var_cte -> ID arr .)
    GREATER         reduce using rule 19 (var_cte -> ID arr .)
    LESS            reduce using rule 19 (var_cte -> ID arr .)
    GREATEROREQUAL  reduce using rule 19 (var_cte -> ID arr .)
    LESSOREQUAL     reduce using rule 19 (var_cte -> ID arr .)
    EQUALEQUALS     reduce using rule 19 (var_cte -> ID arr .)
    DIFFERENT       reduce using rule 19 (var_cte -> ID arr .)
    AND             reduce using rule 19 (var_cte -> ID arr .)
    OR              reduce using rule 19 (var_cte -> ID arr .)
    RSQRTBRACKET    reduce using rule 19 (var_cte -> ID arr .)


state 62

    (12) more_vars_aux -> COMMA vars_aux .

    SEMICOLON       reduce using rule 12 (more_vars_aux -> COMMA vars_aux .)


state 63

    (48) read -> READ LPAR . ID arr_par RPAR SEMICOLON

    ID              shift and go to state 80


state 64

    (50) cicle -> WHILE LPAR . expression RPAR block
    (65) expression -> . conc expression_aux
    (68) conc -> . exp conc_aux
    (71) exp -> . term exp_aux
    (74) term -> . factor term_aux
    (77) factor -> . LPAR expression RPAR
    (78) factor -> . var_cte
    (16) var_cte -> . CTEINT
    (17) var_cte -> . CTEDOUBLE
    (18) var_cte -> . CTEBOOL
    (19) var_cte -> . ID arr
    (20) var_cte -> . func_call
    (57) func_call -> . ID LPAR params RPAR

    LPAR            shift and go to state 74
    CTEINT          shift and go to state 40
    CTEDOUBLE       shift and go to state 37
    CTEBOOL         shift and go to state 39
    ID              shift and go to state 42

    func_call                      shift and go to state 38
    term                           shift and go to state 75
    conc                           shift and go to state 81
    var_cte                        shift and go to state 79
    exp                            shift and go to state 82
    factor                         shift and go to state 78
    expression                     shift and go to state 83

state 65

    (40) more_statement -> statement more_statement .

    RBRACKET        reduce using rule 40 (more_statement -> statement more_statement .)
    RETURN          reduce using rule 40 (more_statement -> statement more_statement .)


state 66

    (49) write -> WRITE LPAR . exp RPAR SEMICOLON
    (71) exp -> . term exp_aux
    (74) term -> . factor term_aux
    (77) factor -> . LPAR expression RPAR
    (78) factor -> . var_cte
    (16) var_cte -> . CTEINT
    (17) var_cte -> . CTEDOUBLE
    (18) var_cte -> . CTEBOOL
    (19) var_cte -> . ID arr
    (20) var_cte -> . func_call
    (57) func_call -> . ID LPAR params RPAR

    LPAR            shift and go to state 74
    CTEINT          shift and go to state 40
    CTEDOUBLE       shift and go to state 37
    CTEBOOL         shift and go to state 39
    ID              shift and go to state 42

    func_call                      shift and go to state 38
    term                           shift and go to state 75
    var_cte                        shift and go to state 79
    exp                            shift and go to state 84
    factor                         shift and go to state 78

state 67

    (63) arr_par -> LSQRTBRACKET . exp RSQRTBRACKET arr_par
    (71) exp -> . term exp_aux
    (74) term -> . factor term_aux
    (77) factor -> . LPAR expression RPAR
    (78) factor -> . var_cte
    (16) var_cte -> . CTEINT
    (17) var_cte -> . CTEDOUBLE
    (18) var_cte -> . CTEBOOL
    (19) var_cte -> . ID arr
    (20) var_cte -> . func_call
    (57) func_call -> . ID LPAR params RPAR

    LPAR            shift and go to state 74
    CTEINT          shift and go to state 40
    CTEDOUBLE       shift and go to state 37
    CTEBOOL         shift and go to state 39
    ID              shift and go to state 42

    func_call                      shift and go to state 38
    term                           shift and go to state 75
    var_cte                        shift and go to state 79
    exp                            shift and go to state 85
    factor                         shift and go to state 78

state 68

    (54) assignation -> ID arr_par . EQUALS assign SEMICOLON

    EQUALS          shift and go to state 86


state 69

    (51) condition -> IF LPAR . expression RPAR block else_posible
    (65) expression -> . conc expression_aux
    (68) conc -> . exp conc_aux
    (71) exp -> . term exp_aux
    (74) term -> . factor term_aux
    (77) factor -> . LPAR expression RPAR
    (78) factor -> . var_cte
    (16) var_cte -> . CTEINT
    (17) var_cte -> . CTEDOUBLE
    (18) var_cte -> . CTEBOOL
    (19) var_cte -> . ID arr
    (20) var_cte -> . func_call
    (57) func_call -> . ID LPAR params RPAR

    LPAR            shift and go to state 74
    CTEINT          shift and go to state 40
    CTEDOUBLE       shift and go to state 37
    CTEBOOL         shift and go to state 39
    ID              shift and go to state 42

    func_call                      shift and go to state 38
    term                           shift and go to state 75
    expression                     shift and go to state 87
    conc                           shift and go to state 81
    var_cte                        shift and go to state 79
    exp                            shift and go to state 82
    factor                         shift and go to state 78

state 70

    (47) statement -> func_call SEMICOLON .

    READ            reduce using rule 47 (statement -> func_call SEMICOLON .)
    WRITE           reduce using rule 47 (statement -> func_call SEMICOLON .)
    WHILE           reduce using rule 47 (statement -> func_call SEMICOLON .)
    IF              reduce using rule 47 (statement -> func_call SEMICOLON .)
    ID              reduce using rule 47 (statement -> func_call SEMICOLON .)
    RETURN          reduce using rule 47 (statement -> func_call SEMICOLON .)
    RBRACKET        reduce using rule 47 (statement -> func_call SEMICOLON .)


state 71

    (93) main_block -> LBRACKET more_vars more_statement RBRACKET .

    $end            reduce using rule 93 (main_block -> LBRACKET more_vars more_statement RBRACKET .)


state 72

    (32) arguments -> var_type . ID to_args more_args

    ID              shift and go to state 88


state 73

    (26) func -> FUNC func_type ID to_proc_dir LPAR arguments . RPAR func_block more_func

    RPAR            shift and go to state 89


state 74

    (77) factor -> LPAR . expression RPAR
    (65) expression -> . conc expression_aux
    (68) conc -> . exp conc_aux
    (71) exp -> . term exp_aux
    (74) term -> . factor term_aux
    (77) factor -> . LPAR expression RPAR
    (78) factor -> . var_cte
    (16) var_cte -> . CTEINT
    (17) var_cte -> . CTEDOUBLE
    (18) var_cte -> . CTEBOOL
    (19) var_cte -> . ID arr
    (20) var_cte -> . func_call
    (57) func_call -> . ID LPAR params RPAR

    LPAR            shift and go to state 74
    CTEINT          shift and go to state 40
    CTEDOUBLE       shift and go to state 37
    CTEBOOL         shift and go to state 39
    ID              shift and go to state 42

    func_call                      shift and go to state 38
    term                           shift and go to state 75
    conc                           shift and go to state 81
    var_cte                        shift and go to state 79
    exp                            shift and go to state 82
    factor                         shift and go to state 78
    expression                     shift and go to state 90

state 75

    (71) exp -> term . exp_aux
    (72) exp_aux -> . pl term exp_aux
    (73) exp_aux -> .
    (87) pl -> . PLUS
    (88) pl -> . MINUS

    COMMA           reduce using rule 73 (exp_aux -> .)
    RPAR            reduce using rule 73 (exp_aux -> .)
    GREATER         reduce using rule 73 (exp_aux -> .)
    LESS            reduce using rule 73 (exp_aux -> .)
    GREATEROREQUAL  reduce using rule 73 (exp_aux -> .)
    LESSOREQUAL     reduce using rule 73 (exp_aux -> .)
    EQUALEQUALS     reduce using rule 73 (exp_aux -> .)
    DIFFERENT       reduce using rule 73 (exp_aux -> .)
    AND             reduce using rule 73 (exp_aux -> .)
    OR              reduce using rule 73 (exp_aux -> .)
    RSQRTBRACKET    reduce using rule 73 (exp_aux -> .)
    SEMICOLON       reduce using rule 73 (exp_aux -> .)
    PLUS            shift and go to state 91
    MINUS           shift and go to state 94

    exp_aux                        shift and go to state 92
    pl                             shift and go to state 93

state 76

    (57) func_call -> ID LPAR params . RPAR

    RPAR            shift and go to state 95


state 77

    (58) params -> exp . more_params
    (60) more_params -> . COMMA exp more_params
    (61) more_params -> .

    COMMA           shift and go to state 97
    RPAR            reduce using rule 61 (more_params -> .)

    more_params                    shift and go to state 96

state 78

    (74) term -> factor . term_aux
    (75) term_aux -> . dm factor term_aux
    (76) term_aux -> .
    (89) dm -> . MULTIPLICATION
    (90) dm -> . DIVISION
    (91) dm -> . MOD

    PLUS            reduce using rule 76 (term_aux -> .)
    MINUS           reduce using rule 76 (term_aux -> .)
    COMMA           reduce using rule 76 (term_aux -> .)
    RPAR            reduce using rule 76 (term_aux -> .)
    GREATER         reduce using rule 76 (term_aux -> .)
    LESS            reduce using rule 76 (term_aux -> .)
    GREATEROREQUAL  reduce using rule 76 (term_aux -> .)
    LESSOREQUAL     reduce using rule 76 (term_aux -> .)
    EQUALEQUALS     reduce using rule 76 (term_aux -> .)
    DIFFERENT       reduce using rule 76 (term_aux -> .)
    AND             reduce using rule 76 (term_aux -> .)
    OR              reduce using rule 76 (term_aux -> .)
    RSQRTBRACKET    reduce using rule 76 (term_aux -> .)
    SEMICOLON       reduce using rule 76 (term_aux -> .)
    MULTIPLICATION  shift and go to state 101
    DIVISION        shift and go to state 98
    MOD             shift and go to state 102

    dm                             shift and go to state 99
    term_aux                       shift and go to state 100

state 79

    (78) factor -> var_cte .

    MULTIPLICATION  reduce using rule 78 (factor -> var_cte .)
    DIVISION        reduce using rule 78 (factor -> var_cte .)
    MOD             reduce using rule 78 (factor -> var_cte .)
    PLUS            reduce using rule 78 (factor -> var_cte .)
    MINUS           reduce using rule 78 (factor -> var_cte .)
    GREATER         reduce using rule 78 (factor -> var_cte .)
    LESS            reduce using rule 78 (factor -> var_cte .)
    GREATEROREQUAL  reduce using rule 78 (factor -> var_cte .)
    LESSOREQUAL     reduce using rule 78 (factor -> var_cte .)
    EQUALEQUALS     reduce using rule 78 (factor -> var_cte .)
    DIFFERENT       reduce using rule 78 (factor -> var_cte .)
    AND             reduce using rule 78 (factor -> var_cte .)
    OR              reduce using rule 78 (factor -> var_cte .)
    RPAR            reduce using rule 78 (factor -> var_cte .)
    COMMA           reduce using rule 78 (factor -> var_cte .)
    SEMICOLON       reduce using rule 78 (factor -> var_cte .)
    RSQRTBRACKET    reduce using rule 78 (factor -> var_cte .)


state 80

    (48) read -> READ LPAR ID . arr_par RPAR SEMICOLON
    (63) arr_par -> . LSQRTBRACKET exp RSQRTBRACKET arr_par
    (64) arr_par -> .

    LSQRTBRACKET    shift and go to state 67
    RPAR            reduce using rule 64 (arr_par -> .)

    arr_par                        shift and go to state 103

state 81

    (65) expression -> conc . expression_aux
    (66) expression_aux -> . ao conc expression_aux
    (67) expression_aux -> .
    (79) ao -> . AND
    (80) ao -> . OR

    RPAR            reduce using rule 67 (expression_aux -> .)
    SEMICOLON       reduce using rule 67 (expression_aux -> .)
    AND             shift and go to state 105
    OR              shift and go to state 106

    expression_aux                 shift and go to state 104
    ao                             shift and go to state 107

state 82

    (68) conc -> exp . conc_aux
    (69) conc_aux -> . comp exp
    (70) conc_aux -> .
    (81) comp -> . GREATER
    (82) comp -> . LESS
    (83) comp -> . GREATEROREQUAL
    (84) comp -> . LESSOREQUAL
    (85) comp -> . EQUALEQUALS
    (86) comp -> . DIFFERENT

    AND             reduce using rule 70 (conc_aux -> .)
    OR              reduce using rule 70 (conc_aux -> .)
    RPAR            reduce using rule 70 (conc_aux -> .)
    SEMICOLON       reduce using rule 70 (conc_aux -> .)
    GREATER         shift and go to state 110
    LESS            shift and go to state 111
    GREATEROREQUAL  shift and go to state 114
    LESSOREQUAL     shift and go to state 109
    EQUALEQUALS     shift and go to state 112
    DIFFERENT       shift and go to state 108

    conc_aux                       shift and go to state 115
    comp                           shift and go to state 113

state 83

    (50) cicle -> WHILE LPAR expression . RPAR block

    RPAR            shift and go to state 116


state 84

    (49) write -> WRITE LPAR exp . RPAR SEMICOLON

    RPAR            shift and go to state 117


state 85

    (63) arr_par -> LSQRTBRACKET exp . RSQRTBRACKET arr_par

    RSQRTBRACKET    shift and go to state 118


state 86

    (54) assignation -> ID arr_par EQUALS . assign SEMICOLON
    (55) assign -> . expression
    (56) assign -> . func_call
    (65) expression -> . conc expression_aux
    (57) func_call -> . ID LPAR params RPAR
    (68) conc -> . exp conc_aux
    (71) exp -> . term exp_aux
    (74) term -> . factor term_aux
    (77) factor -> . LPAR expression RPAR
    (78) factor -> . var_cte
    (16) var_cte -> . CTEINT
    (17) var_cte -> . CTEDOUBLE
    (18) var_cte -> . CTEBOOL
    (19) var_cte -> . ID arr
    (20) var_cte -> . func_call

    ID              shift and go to state 119
    LPAR            shift and go to state 74
    CTEINT          shift and go to state 40
    CTEDOUBLE       shift and go to state 37
    CTEBOOL         shift and go to state 39

    func_call                      shift and go to state 120
    term                           shift and go to state 75
    conc                           shift and go to state 81
    exp                            shift and go to state 82
    factor                         shift and go to state 78
    var_cte                        shift and go to state 79
    expression                     shift and go to state 122
    assign                         shift and go to state 121

state 87

    (51) condition -> IF LPAR expression . RPAR block else_posible

    RPAR            shift and go to state 123


state 88

    (32) arguments -> var_type ID . to_args more_args
    (36) to_args -> .

    COMMA           reduce using rule 36 (to_args -> .)
    RPAR            reduce using rule 36 (to_args -> .)

    to_args                        shift and go to state 124

state 89

    (26) func -> FUNC func_type ID to_proc_dir LPAR arguments RPAR . func_block more_func
    (37) func_block -> . LBRACKET more_vars more_statement optional_return RBRACKET

    LBRACKET        shift and go to state 126

    func_block                     shift and go to state 125

state 90

    (77) factor -> LPAR expression . RPAR

    RPAR            shift and go to state 127


state 91

    (87) pl -> PLUS .

    LPAR            reduce using rule 87 (pl -> PLUS .)
    CTEINT          reduce using rule 87 (pl -> PLUS .)
    CTEDOUBLE       reduce using rule 87 (pl -> PLUS .)
    CTEBOOL         reduce using rule 87 (pl -> PLUS .)
    ID              reduce using rule 87 (pl -> PLUS .)


state 92

    (71) exp -> term exp_aux .

    AND             reduce using rule 71 (exp -> term exp_aux .)
    OR              reduce using rule 71 (exp -> term exp_aux .)
    RPAR            reduce using rule 71 (exp -> term exp_aux .)
    SEMICOLON       reduce using rule 71 (exp -> term exp_aux .)
    GREATER         reduce using rule 71 (exp -> term exp_aux .)
    LESS            reduce using rule 71 (exp -> term exp_aux .)
    GREATEROREQUAL  reduce using rule 71 (exp -> term exp_aux .)
    LESSOREQUAL     reduce using rule 71 (exp -> term exp_aux .)
    EQUALEQUALS     reduce using rule 71 (exp -> term exp_aux .)
    DIFFERENT       reduce using rule 71 (exp -> term exp_aux .)
    COMMA           reduce using rule 71 (exp -> term exp_aux .)
    RSQRTBRACKET    reduce using rule 71 (exp -> term exp_aux .)


state 93

    (72) exp_aux -> pl . term exp_aux
    (74) term -> . factor term_aux
    (77) factor -> . LPAR expression RPAR
    (78) factor -> . var_cte
    (16) var_cte -> . CTEINT
    (17) var_cte -> . CTEDOUBLE
    (18) var_cte -> . CTEBOOL
    (19) var_cte -> . ID arr
    (20) var_cte -> . func_call
    (57) func_call -> . ID LPAR params RPAR

    LPAR            shift and go to state 74
    CTEINT          shift and go to state 40
    CTEDOUBLE       shift and go to state 37
    CTEBOOL         shift and go to state 39
    ID              shift and go to state 42

    func_call                      shift and go to state 38
    term                           shift and go to state 128
    var_cte                        shift and go to state 79
    factor                         shift and go to state 78

state 94

    (88) pl -> MINUS .

    LPAR            reduce using rule 88 (pl -> MINUS .)
    CTEINT          reduce using rule 88 (pl -> MINUS .)
    CTEDOUBLE       reduce using rule 88 (pl -> MINUS .)
    CTEBOOL         reduce using rule 88 (pl -> MINUS .)
    ID              reduce using rule 88 (pl -> MINUS .)


state 95

    (57) func_call -> ID LPAR params RPAR .

    MULTIPLICATION  reduce using rule 57 (func_call -> ID LPAR params RPAR .)
    DIVISION        reduce using rule 57 (func_call -> ID LPAR params RPAR .)
    MOD             reduce using rule 57 (func_call -> ID LPAR params RPAR .)
    PLUS            reduce using rule 57 (func_call -> ID LPAR params RPAR .)
    MINUS           reduce using rule 57 (func_call -> ID LPAR params RPAR .)
    SEMICOLON       reduce using rule 57 (func_call -> ID LPAR params RPAR .)
    AND             reduce using rule 57 (func_call -> ID LPAR params RPAR .)
    OR              reduce using rule 57 (func_call -> ID LPAR params RPAR .)
    RPAR            reduce using rule 57 (func_call -> ID LPAR params RPAR .)
    COMMA           reduce using rule 57 (func_call -> ID LPAR params RPAR .)
    GREATER         reduce using rule 57 (func_call -> ID LPAR params RPAR .)
    LESS            reduce using rule 57 (func_call -> ID LPAR params RPAR .)
    GREATEROREQUAL  reduce using rule 57 (func_call -> ID LPAR params RPAR .)
    LESSOREQUAL     reduce using rule 57 (func_call -> ID LPAR params RPAR .)
    EQUALEQUALS     reduce using rule 57 (func_call -> ID LPAR params RPAR .)
    DIFFERENT       reduce using rule 57 (func_call -> ID LPAR params RPAR .)
    RSQRTBRACKET    reduce using rule 57 (func_call -> ID LPAR params RPAR .)


state 96

    (58) params -> exp more_params .

    RPAR            reduce using rule 58 (params -> exp more_params .)


state 97

    (60) more_params -> COMMA . exp more_params
    (71) exp -> . term exp_aux
    (74) term -> . factor term_aux
    (77) factor -> . LPAR expression RPAR
    (78) factor -> . var_cte
    (16) var_cte -> . CTEINT
    (17) var_cte -> . CTEDOUBLE
    (18) var_cte -> . CTEBOOL
    (19) var_cte -> . ID arr
    (20) var_cte -> . func_call
    (57) func_call -> . ID LPAR params RPAR

    LPAR            shift and go to state 74
    CTEINT          shift and go to state 40
    CTEDOUBLE       shift and go to state 37
    CTEBOOL         shift and go to state 39
    ID              shift and go to state 42

    func_call                      shift and go to state 38
    term                           shift and go to state 75
    var_cte                        shift and go to state 79
    exp                            shift and go to state 129
    factor                         shift and go to state 78

state 98

    (90) dm -> DIVISION .

    LPAR            reduce using rule 90 (dm -> DIVISION .)
    CTEINT          reduce using rule 90 (dm -> DIVISION .)
    CTEDOUBLE       reduce using rule 90 (dm -> DIVISION .)
    CTEBOOL         reduce using rule 90 (dm -> DIVISION .)
    ID              reduce using rule 90 (dm -> DIVISION .)


state 99

    (75) term_aux -> dm . factor term_aux
    (77) factor -> . LPAR expression RPAR
    (78) factor -> . var_cte
    (16) var_cte -> . CTEINT
    (17) var_cte -> . CTEDOUBLE
    (18) var_cte -> . CTEBOOL
    (19) var_cte -> . ID arr
    (20) var_cte -> . func_call
    (57) func_call -> . ID LPAR params RPAR

    LPAR            shift and go to state 74
    CTEINT          shift and go to state 40
    CTEDOUBLE       shift and go to state 37
    CTEBOOL         shift and go to state 39
    ID              shift and go to state 42

    func_call                      shift and go to state 38
    var_cte                        shift and go to state 79
    factor                         shift and go to state 130

state 100

    (74) term -> factor term_aux .

    PLUS            reduce using rule 74 (term -> factor term_aux .)
    MINUS           reduce using rule 74 (term -> factor term_aux .)
    GREATER         reduce using rule 74 (term -> factor term_aux .)
    LESS            reduce using rule 74 (term -> factor term_aux .)
    GREATEROREQUAL  reduce using rule 74 (term -> factor term_aux .)
    LESSOREQUAL     reduce using rule 74 (term -> factor term_aux .)
    EQUALEQUALS     reduce using rule 74 (term -> factor term_aux .)
    DIFFERENT       reduce using rule 74 (term -> factor term_aux .)
    AND             reduce using rule 74 (term -> factor term_aux .)
    OR              reduce using rule 74 (term -> factor term_aux .)
    RPAR            reduce using rule 74 (term -> factor term_aux .)
    SEMICOLON       reduce using rule 74 (term -> factor term_aux .)
    COMMA           reduce using rule 74 (term -> factor term_aux .)
    RSQRTBRACKET    reduce using rule 74 (term -> factor term_aux .)


state 101

    (89) dm -> MULTIPLICATION .

    LPAR            reduce using rule 89 (dm -> MULTIPLICATION .)
    CTEINT          reduce using rule 89 (dm -> MULTIPLICATION .)
    CTEDOUBLE       reduce using rule 89 (dm -> MULTIPLICATION .)
    CTEBOOL         reduce using rule 89 (dm -> MULTIPLICATION .)
    ID              reduce using rule 89 (dm -> MULTIPLICATION .)


state 102

    (91) dm -> MOD .

    LPAR            reduce using rule 91 (dm -> MOD .)
    CTEINT          reduce using rule 91 (dm -> MOD .)
    CTEDOUBLE       reduce using rule 91 (dm -> MOD .)
    CTEBOOL         reduce using rule 91 (dm -> MOD .)
    ID              reduce using rule 91 (dm -> MOD .)


state 103

    (48) read -> READ LPAR ID arr_par . RPAR SEMICOLON

    RPAR            shift and go to state 131


state 104

    (65) expression -> conc expression_aux .

    RPAR            reduce using rule 65 (expression -> conc expression_aux .)
    SEMICOLON       reduce using rule 65 (expression -> conc expression_aux .)


state 105

    (79) ao -> AND .

    LPAR            reduce using rule 79 (ao -> AND .)
    CTEINT          reduce using rule 79 (ao -> AND .)
    CTEDOUBLE       reduce using rule 79 (ao -> AND .)
    CTEBOOL         reduce using rule 79 (ao -> AND .)
    ID              reduce using rule 79 (ao -> AND .)


state 106

    (80) ao -> OR .

    LPAR            reduce using rule 80 (ao -> OR .)
    CTEINT          reduce using rule 80 (ao -> OR .)
    CTEDOUBLE       reduce using rule 80 (ao -> OR .)
    CTEBOOL         reduce using rule 80 (ao -> OR .)
    ID              reduce using rule 80 (ao -> OR .)


state 107

    (66) expression_aux -> ao . conc expression_aux
    (68) conc -> . exp conc_aux
    (71) exp -> . term exp_aux
    (74) term -> . factor term_aux
    (77) factor -> . LPAR expression RPAR
    (78) factor -> . var_cte
    (16) var_cte -> . CTEINT
    (17) var_cte -> . CTEDOUBLE
    (18) var_cte -> . CTEBOOL
    (19) var_cte -> . ID arr
    (20) var_cte -> . func_call
    (57) func_call -> . ID LPAR params RPAR

    LPAR            shift and go to state 74
    CTEINT          shift and go to state 40
    CTEDOUBLE       shift and go to state 37
    CTEBOOL         shift and go to state 39
    ID              shift and go to state 42

    func_call                      shift and go to state 38
    term                           shift and go to state 75
    conc                           shift and go to state 132
    var_cte                        shift and go to state 79
    exp                            shift and go to state 82
    factor                         shift and go to state 78

state 108

    (86) comp -> DIFFERENT .

    LPAR            reduce using rule 86 (comp -> DIFFERENT .)
    CTEINT          reduce using rule 86 (comp -> DIFFERENT .)
    CTEDOUBLE       reduce using rule 86 (comp -> DIFFERENT .)
    CTEBOOL         reduce using rule 86 (comp -> DIFFERENT .)
    ID              reduce using rule 86 (comp -> DIFFERENT .)


state 109

    (84) comp -> LESSOREQUAL .

    LPAR            reduce using rule 84 (comp -> LESSOREQUAL .)
    CTEINT          reduce using rule 84 (comp -> LESSOREQUAL .)
    CTEDOUBLE       reduce using rule 84 (comp -> LESSOREQUAL .)
    CTEBOOL         reduce using rule 84 (comp -> LESSOREQUAL .)
    ID              reduce using rule 84 (comp -> LESSOREQUAL .)


state 110

    (81) comp -> GREATER .

    LPAR            reduce using rule 81 (comp -> GREATER .)
    CTEINT          reduce using rule 81 (comp -> GREATER .)
    CTEDOUBLE       reduce using rule 81 (comp -> GREATER .)
    CTEBOOL         reduce using rule 81 (comp -> GREATER .)
    ID              reduce using rule 81 (comp -> GREATER .)


state 111

    (82) comp -> LESS .

    LPAR            reduce using rule 82 (comp -> LESS .)
    CTEINT          reduce using rule 82 (comp -> LESS .)
    CTEDOUBLE       reduce using rule 82 (comp -> LESS .)
    CTEBOOL         reduce using rule 82 (comp -> LESS .)
    ID              reduce using rule 82 (comp -> LESS .)


state 112

    (85) comp -> EQUALEQUALS .

    LPAR            reduce using rule 85 (comp -> EQUALEQUALS .)
    CTEINT          reduce using rule 85 (comp -> EQUALEQUALS .)
    CTEDOUBLE       reduce using rule 85 (comp -> EQUALEQUALS .)
    CTEBOOL         reduce using rule 85 (comp -> EQUALEQUALS .)
    ID              reduce using rule 85 (comp -> EQUALEQUALS .)


state 113

    (69) conc_aux -> comp . exp
    (71) exp -> . term exp_aux
    (74) term -> . factor term_aux
    (77) factor -> . LPAR expression RPAR
    (78) factor -> . var_cte
    (16) var_cte -> . CTEINT
    (17) var_cte -> . CTEDOUBLE
    (18) var_cte -> . CTEBOOL
    (19) var_cte -> . ID arr
    (20) var_cte -> . func_call
    (57) func_call -> . ID LPAR params RPAR

    LPAR            shift and go to state 74
    CTEINT          shift and go to state 40
    CTEDOUBLE       shift and go to state 37
    CTEBOOL         shift and go to state 39
    ID              shift and go to state 42

    func_call                      shift and go to state 38
    term                           shift and go to state 75
    var_cte                        shift and go to state 79
    exp                            shift and go to state 133
    factor                         shift and go to state 78

state 114

    (83) comp -> GREATEROREQUAL .

    LPAR            reduce using rule 83 (comp -> GREATEROREQUAL .)
    CTEINT          reduce using rule 83 (comp -> GREATEROREQUAL .)
    CTEDOUBLE       reduce using rule 83 (comp -> GREATEROREQUAL .)
    CTEBOOL         reduce using rule 83 (comp -> GREATEROREQUAL .)
    ID              reduce using rule 83 (comp -> GREATEROREQUAL .)


state 115

    (68) conc -> exp conc_aux .

    AND             reduce using rule 68 (conc -> exp conc_aux .)
    OR              reduce using rule 68 (conc -> exp conc_aux .)
    RPAR            reduce using rule 68 (conc -> exp conc_aux .)
    SEMICOLON       reduce using rule 68 (conc -> exp conc_aux .)


state 116

    (50) cicle -> WHILE LPAR expression RPAR . block
    (62) block -> . LBRACKET more_statement RBRACKET

    LBRACKET        shift and go to state 134

    block                          shift and go to state 135

state 117

    (49) write -> WRITE LPAR exp RPAR . SEMICOLON

    SEMICOLON       shift and go to state 136


state 118

    (63) arr_par -> LSQRTBRACKET exp RSQRTBRACKET . arr_par
    (63) arr_par -> . LSQRTBRACKET exp RSQRTBRACKET arr_par
    (64) arr_par -> .

    LSQRTBRACKET    shift and go to state 67
    EQUALS          reduce using rule 64 (arr_par -> .)
    RPAR            reduce using rule 64 (arr_par -> .)

    arr_par                        shift and go to state 137

state 119

    (57) func_call -> ID . LPAR params RPAR
    (19) var_cte -> ID . arr
    (14) arr -> . LSQRTBRACKET const RSQRTBRACKET arr
    (15) arr -> .

    LPAR            shift and go to state 60
    LSQRTBRACKET    shift and go to state 15
    MULTIPLICATION  reduce using rule 15 (arr -> .)
    DIVISION        reduce using rule 15 (arr -> .)
    MOD             reduce using rule 15 (arr -> .)
    PLUS            reduce using rule 15 (arr -> .)
    MINUS           reduce using rule 15 (arr -> .)
    GREATER         reduce using rule 15 (arr -> .)
    LESS            reduce using rule 15 (arr -> .)
    GREATEROREQUAL  reduce using rule 15 (arr -> .)
    LESSOREQUAL     reduce using rule 15 (arr -> .)
    EQUALEQUALS     reduce using rule 15 (arr -> .)
    DIFFERENT       reduce using rule 15 (arr -> .)
    AND             reduce using rule 15 (arr -> .)
    OR              reduce using rule 15 (arr -> .)
    SEMICOLON       reduce using rule 15 (arr -> .)

    arr                            shift and go to state 61

state 120

    (56) assign -> func_call .
    (20) var_cte -> func_call .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 20 (var_cte -> func_call .)
    MULTIPLICATION  reduce using rule 20 (var_cte -> func_call .)
    DIVISION        reduce using rule 20 (var_cte -> func_call .)
    MOD             reduce using rule 20 (var_cte -> func_call .)
    PLUS            reduce using rule 20 (var_cte -> func_call .)
    MINUS           reduce using rule 20 (var_cte -> func_call .)
    GREATER         reduce using rule 20 (var_cte -> func_call .)
    LESS            reduce using rule 20 (var_cte -> func_call .)
    GREATEROREQUAL  reduce using rule 20 (var_cte -> func_call .)
    LESSOREQUAL     reduce using rule 20 (var_cte -> func_call .)
    EQUALEQUALS     reduce using rule 20 (var_cte -> func_call .)
    DIFFERENT       reduce using rule 20 (var_cte -> func_call .)
    AND             reduce using rule 20 (var_cte -> func_call .)
    OR              reduce using rule 20 (var_cte -> func_call .)
    SEMICOLON       reduce using rule 20 (var_cte -> func_call .)

  ! SEMICOLON       [ reduce using rule 56 (assign -> func_call .) ]


state 121

    (54) assignation -> ID arr_par EQUALS assign . SEMICOLON

    SEMICOLON       shift and go to state 138


state 122

    (55) assign -> expression .

    SEMICOLON       reduce using rule 55 (assign -> expression .)


state 123

    (51) condition -> IF LPAR expression RPAR . block else_posible
    (62) block -> . LBRACKET more_statement RBRACKET

    LBRACKET        shift and go to state 134

    block                          shift and go to state 139

state 124

    (32) arguments -> var_type ID to_args . more_args
    (34) more_args -> . COMMA var_type ID to_args more_args
    (35) more_args -> .

    COMMA           shift and go to state 141
    RPAR            reduce using rule 35 (more_args -> .)

    more_args                      shift and go to state 140

state 125

    (26) func -> FUNC func_type ID to_proc_dir LPAR arguments RPAR func_block . more_func
    (24) more_func -> . func
    (25) more_func -> .
    (26) func -> . FUNC func_type ID to_proc_dir LPAR arguments RPAR func_block more_func

    MAIN            reduce using rule 25 (more_func -> .)
    FUNC            shift and go to state 12

    func                           shift and go to state 10
    more_func                      shift and go to state 142

state 126

    (37) func_block -> LBRACKET . more_vars more_statement optional_return RBRACKET
    (2) more_vars -> . vars
    (3) more_vars -> .
    (4) vars -> . var_type vars_aux SEMICOLON more_vars
    (5) var_type -> . BOOL
    (6) var_type -> . INT
    (7) var_type -> . DOUBLE

    READ            reduce using rule 3 (more_vars -> .)
    WRITE           reduce using rule 3 (more_vars -> .)
    WHILE           reduce using rule 3 (more_vars -> .)
    IF              reduce using rule 3 (more_vars -> .)
    ID              reduce using rule 3 (more_vars -> .)
    RETURN          reduce using rule 3 (more_vars -> .)
    RBRACKET        reduce using rule 3 (more_vars -> .)
    BOOL            shift and go to state 6
    INT             shift and go to state 3
    DOUBLE          shift and go to state 4

    var_type                       shift and go to state 2
    vars                           shift and go to state 1
    more_vars                      shift and go to state 143

state 127

    (77) factor -> LPAR expression RPAR .

    MULTIPLICATION  reduce using rule 77 (factor -> LPAR expression RPAR .)
    DIVISION        reduce using rule 77 (factor -> LPAR expression RPAR .)
    MOD             reduce using rule 77 (factor -> LPAR expression RPAR .)
    PLUS            reduce using rule 77 (factor -> LPAR expression RPAR .)
    MINUS           reduce using rule 77 (factor -> LPAR expression RPAR .)
    GREATER         reduce using rule 77 (factor -> LPAR expression RPAR .)
    LESS            reduce using rule 77 (factor -> LPAR expression RPAR .)
    GREATEROREQUAL  reduce using rule 77 (factor -> LPAR expression RPAR .)
    LESSOREQUAL     reduce using rule 77 (factor -> LPAR expression RPAR .)
    EQUALEQUALS     reduce using rule 77 (factor -> LPAR expression RPAR .)
    DIFFERENT       reduce using rule 77 (factor -> LPAR expression RPAR .)
    AND             reduce using rule 77 (factor -> LPAR expression RPAR .)
    OR              reduce using rule 77 (factor -> LPAR expression RPAR .)
    RPAR            reduce using rule 77 (factor -> LPAR expression RPAR .)
    COMMA           reduce using rule 77 (factor -> LPAR expression RPAR .)
    SEMICOLON       reduce using rule 77 (factor -> LPAR expression RPAR .)
    RSQRTBRACKET    reduce using rule 77 (factor -> LPAR expression RPAR .)


state 128

    (72) exp_aux -> pl term . exp_aux
    (72) exp_aux -> . pl term exp_aux
    (73) exp_aux -> .
    (87) pl -> . PLUS
    (88) pl -> . MINUS

    COMMA           reduce using rule 73 (exp_aux -> .)
    RPAR            reduce using rule 73 (exp_aux -> .)
    GREATER         reduce using rule 73 (exp_aux -> .)
    LESS            reduce using rule 73 (exp_aux -> .)
    GREATEROREQUAL  reduce using rule 73 (exp_aux -> .)
    LESSOREQUAL     reduce using rule 73 (exp_aux -> .)
    EQUALEQUALS     reduce using rule 73 (exp_aux -> .)
    DIFFERENT       reduce using rule 73 (exp_aux -> .)
    AND             reduce using rule 73 (exp_aux -> .)
    OR              reduce using rule 73 (exp_aux -> .)
    RSQRTBRACKET    reduce using rule 73 (exp_aux -> .)
    SEMICOLON       reduce using rule 73 (exp_aux -> .)
    PLUS            shift and go to state 91
    MINUS           shift and go to state 94

    exp_aux                        shift and go to state 144
    pl                             shift and go to state 93

state 129

    (60) more_params -> COMMA exp . more_params
    (60) more_params -> . COMMA exp more_params
    (61) more_params -> .

    COMMA           shift and go to state 97
    RPAR            reduce using rule 61 (more_params -> .)

    more_params                    shift and go to state 145

state 130

    (75) term_aux -> dm factor . term_aux
    (75) term_aux -> . dm factor term_aux
    (76) term_aux -> .
    (89) dm -> . MULTIPLICATION
    (90) dm -> . DIVISION
    (91) dm -> . MOD

    PLUS            reduce using rule 76 (term_aux -> .)
    MINUS           reduce using rule 76 (term_aux -> .)
    COMMA           reduce using rule 76 (term_aux -> .)
    RPAR            reduce using rule 76 (term_aux -> .)
    GREATER         reduce using rule 76 (term_aux -> .)
    LESS            reduce using rule 76 (term_aux -> .)
    GREATEROREQUAL  reduce using rule 76 (term_aux -> .)
    LESSOREQUAL     reduce using rule 76 (term_aux -> .)
    EQUALEQUALS     reduce using rule 76 (term_aux -> .)
    DIFFERENT       reduce using rule 76 (term_aux -> .)
    AND             reduce using rule 76 (term_aux -> .)
    OR              reduce using rule 76 (term_aux -> .)
    RSQRTBRACKET    reduce using rule 76 (term_aux -> .)
    SEMICOLON       reduce using rule 76 (term_aux -> .)
    MULTIPLICATION  shift and go to state 101
    DIVISION        shift and go to state 98
    MOD             shift and go to state 102

    dm                             shift and go to state 99
    term_aux                       shift and go to state 146

state 131

    (48) read -> READ LPAR ID arr_par RPAR . SEMICOLON

    SEMICOLON       shift and go to state 147


state 132

    (66) expression_aux -> ao conc . expression_aux
    (66) expression_aux -> . ao conc expression_aux
    (67) expression_aux -> .
    (79) ao -> . AND
    (80) ao -> . OR

    RPAR            reduce using rule 67 (expression_aux -> .)
    SEMICOLON       reduce using rule 67 (expression_aux -> .)
    AND             shift and go to state 105
    OR              shift and go to state 106

    expression_aux                 shift and go to state 148
    ao                             shift and go to state 107

state 133

    (69) conc_aux -> comp exp .

    AND             reduce using rule 69 (conc_aux -> comp exp .)
    OR              reduce using rule 69 (conc_aux -> comp exp .)
    RPAR            reduce using rule 69 (conc_aux -> comp exp .)
    SEMICOLON       reduce using rule 69 (conc_aux -> comp exp .)


state 134

    (62) block -> LBRACKET . more_statement RBRACKET
    (40) more_statement -> . statement more_statement
    (41) more_statement -> .
    (42) statement -> . read
    (43) statement -> . write
    (44) statement -> . cicle
    (45) statement -> . condition
    (46) statement -> . assignation
    (47) statement -> . func_call SEMICOLON
    (48) read -> . READ LPAR ID arr_par RPAR SEMICOLON
    (49) write -> . WRITE LPAR exp RPAR SEMICOLON
    (50) cicle -> . WHILE LPAR expression RPAR block
    (51) condition -> . IF LPAR expression RPAR block else_posible
    (54) assignation -> . ID arr_par EQUALS assign SEMICOLON
    (57) func_call -> . ID LPAR params RPAR

    RBRACKET        reduce using rule 41 (more_statement -> .)
    READ            shift and go to state 46
    WRITE           shift and go to state 52
    WHILE           shift and go to state 47
    IF              shift and go to state 55
    ID              shift and go to state 53

    func_call                      shift and go to state 56
    assignation                    shift and go to state 57
    read                           shift and go to state 51
    cicle                          shift and go to state 48
    write                          shift and go to state 49
    statement                      shift and go to state 50
    more_statement                 shift and go to state 149
    condition                      shift and go to state 54

state 135

    (50) cicle -> WHILE LPAR expression RPAR block .

    READ            reduce using rule 50 (cicle -> WHILE LPAR expression RPAR block .)
    WRITE           reduce using rule 50 (cicle -> WHILE LPAR expression RPAR block .)
    WHILE           reduce using rule 50 (cicle -> WHILE LPAR expression RPAR block .)
    IF              reduce using rule 50 (cicle -> WHILE LPAR expression RPAR block .)
    ID              reduce using rule 50 (cicle -> WHILE LPAR expression RPAR block .)
    RETURN          reduce using rule 50 (cicle -> WHILE LPAR expression RPAR block .)
    RBRACKET        reduce using rule 50 (cicle -> WHILE LPAR expression RPAR block .)


state 136

    (49) write -> WRITE LPAR exp RPAR SEMICOLON .

    READ            reduce using rule 49 (write -> WRITE LPAR exp RPAR SEMICOLON .)
    WRITE           reduce using rule 49 (write -> WRITE LPAR exp RPAR SEMICOLON .)
    WHILE           reduce using rule 49 (write -> WRITE LPAR exp RPAR SEMICOLON .)
    IF              reduce using rule 49 (write -> WRITE LPAR exp RPAR SEMICOLON .)
    ID              reduce using rule 49 (write -> WRITE LPAR exp RPAR SEMICOLON .)
    RBRACKET        reduce using rule 49 (write -> WRITE LPAR exp RPAR SEMICOLON .)
    RETURN          reduce using rule 49 (write -> WRITE LPAR exp RPAR SEMICOLON .)


state 137

    (63) arr_par -> LSQRTBRACKET exp RSQRTBRACKET arr_par .

    RPAR            reduce using rule 63 (arr_par -> LSQRTBRACKET exp RSQRTBRACKET arr_par .)
    EQUALS          reduce using rule 63 (arr_par -> LSQRTBRACKET exp RSQRTBRACKET arr_par .)


state 138

    (54) assignation -> ID arr_par EQUALS assign SEMICOLON .

    READ            reduce using rule 54 (assignation -> ID arr_par EQUALS assign SEMICOLON .)
    WRITE           reduce using rule 54 (assignation -> ID arr_par EQUALS assign SEMICOLON .)
    WHILE           reduce using rule 54 (assignation -> ID arr_par EQUALS assign SEMICOLON .)
    IF              reduce using rule 54 (assignation -> ID arr_par EQUALS assign SEMICOLON .)
    ID              reduce using rule 54 (assignation -> ID arr_par EQUALS assign SEMICOLON .)
    RBRACKET        reduce using rule 54 (assignation -> ID arr_par EQUALS assign SEMICOLON .)
    RETURN          reduce using rule 54 (assignation -> ID arr_par EQUALS assign SEMICOLON .)


state 139

    (51) condition -> IF LPAR expression RPAR block . else_posible
    (52) else_posible -> . ELSE block
    (53) else_posible -> .

    ELSE            shift and go to state 151
    READ            reduce using rule 53 (else_posible -> .)
    WRITE           reduce using rule 53 (else_posible -> .)
    WHILE           reduce using rule 53 (else_posible -> .)
    IF              reduce using rule 53 (else_posible -> .)
    ID              reduce using rule 53 (else_posible -> .)
    RBRACKET        reduce using rule 53 (else_posible -> .)
    RETURN          reduce using rule 53 (else_posible -> .)

    else_posible                   shift and go to state 150

state 140

    (32) arguments -> var_type ID to_args more_args .

    RPAR            reduce using rule 32 (arguments -> var_type ID to_args more_args .)


state 141

    (34) more_args -> COMMA . var_type ID to_args more_args
    (5) var_type -> . BOOL
    (6) var_type -> . INT
    (7) var_type -> . DOUBLE

    BOOL            shift and go to state 6
    INT             shift and go to state 3
    DOUBLE          shift and go to state 4

    var_type                       shift and go to state 152

state 142

    (26) func -> FUNC func_type ID to_proc_dir LPAR arguments RPAR func_block more_func .

    MAIN            reduce using rule 26 (func -> FUNC func_type ID to_proc_dir LPAR arguments RPAR func_block more_func .)


state 143

    (37) func_block -> LBRACKET more_vars . more_statement optional_return RBRACKET
    (40) more_statement -> . statement more_statement
    (41) more_statement -> .
    (42) statement -> . read
    (43) statement -> . write
    (44) statement -> . cicle
    (45) statement -> . condition
    (46) statement -> . assignation
    (47) statement -> . func_call SEMICOLON
    (48) read -> . READ LPAR ID arr_par RPAR SEMICOLON
    (49) write -> . WRITE LPAR exp RPAR SEMICOLON
    (50) cicle -> . WHILE LPAR expression RPAR block
    (51) condition -> . IF LPAR expression RPAR block else_posible
    (54) assignation -> . ID arr_par EQUALS assign SEMICOLON
    (57) func_call -> . ID LPAR params RPAR

    RETURN          reduce using rule 41 (more_statement -> .)
    RBRACKET        reduce using rule 41 (more_statement -> .)
    READ            shift and go to state 46
    WRITE           shift and go to state 52
    WHILE           shift and go to state 47
    IF              shift and go to state 55
    ID              shift and go to state 53

    func_call                      shift and go to state 56
    assignation                    shift and go to state 57
    read                           shift and go to state 51
    more_statement                 shift and go to state 153
    write                          shift and go to state 49
    condition                      shift and go to state 54
    statement                      shift and go to state 50
    cicle                          shift and go to state 48

state 144

    (72) exp_aux -> pl term exp_aux .

    COMMA           reduce using rule 72 (exp_aux -> pl term exp_aux .)
    RPAR            reduce using rule 72 (exp_aux -> pl term exp_aux .)
    GREATER         reduce using rule 72 (exp_aux -> pl term exp_aux .)
    LESS            reduce using rule 72 (exp_aux -> pl term exp_aux .)
    GREATEROREQUAL  reduce using rule 72 (exp_aux -> pl term exp_aux .)
    LESSOREQUAL     reduce using rule 72 (exp_aux -> pl term exp_aux .)
    EQUALEQUALS     reduce using rule 72 (exp_aux -> pl term exp_aux .)
    DIFFERENT       reduce using rule 72 (exp_aux -> pl term exp_aux .)
    AND             reduce using rule 72 (exp_aux -> pl term exp_aux .)
    OR              reduce using rule 72 (exp_aux -> pl term exp_aux .)
    RSQRTBRACKET    reduce using rule 72 (exp_aux -> pl term exp_aux .)
    SEMICOLON       reduce using rule 72 (exp_aux -> pl term exp_aux .)


state 145

    (60) more_params -> COMMA exp more_params .

    RPAR            reduce using rule 60 (more_params -> COMMA exp more_params .)


state 146

    (75) term_aux -> dm factor term_aux .

    PLUS            reduce using rule 75 (term_aux -> dm factor term_aux .)
    MINUS           reduce using rule 75 (term_aux -> dm factor term_aux .)
    COMMA           reduce using rule 75 (term_aux -> dm factor term_aux .)
    RPAR            reduce using rule 75 (term_aux -> dm factor term_aux .)
    GREATER         reduce using rule 75 (term_aux -> dm factor term_aux .)
    LESS            reduce using rule 75 (term_aux -> dm factor term_aux .)
    GREATEROREQUAL  reduce using rule 75 (term_aux -> dm factor term_aux .)
    LESSOREQUAL     reduce using rule 75 (term_aux -> dm factor term_aux .)
    EQUALEQUALS     reduce using rule 75 (term_aux -> dm factor term_aux .)
    DIFFERENT       reduce using rule 75 (term_aux -> dm factor term_aux .)
    AND             reduce using rule 75 (term_aux -> dm factor term_aux .)
    OR              reduce using rule 75 (term_aux -> dm factor term_aux .)
    RSQRTBRACKET    reduce using rule 75 (term_aux -> dm factor term_aux .)
    SEMICOLON       reduce using rule 75 (term_aux -> dm factor term_aux .)


state 147

    (48) read -> READ LPAR ID arr_par RPAR SEMICOLON .

    READ            reduce using rule 48 (read -> READ LPAR ID arr_par RPAR SEMICOLON .)
    WRITE           reduce using rule 48 (read -> READ LPAR ID arr_par RPAR SEMICOLON .)
    WHILE           reduce using rule 48 (read -> READ LPAR ID arr_par RPAR SEMICOLON .)
    IF              reduce using rule 48 (read -> READ LPAR ID arr_par RPAR SEMICOLON .)
    ID              reduce using rule 48 (read -> READ LPAR ID arr_par RPAR SEMICOLON .)
    RETURN          reduce using rule 48 (read -> READ LPAR ID arr_par RPAR SEMICOLON .)
    RBRACKET        reduce using rule 48 (read -> READ LPAR ID arr_par RPAR SEMICOLON .)


state 148

    (66) expression_aux -> ao conc expression_aux .

    RPAR            reduce using rule 66 (expression_aux -> ao conc expression_aux .)
    SEMICOLON       reduce using rule 66 (expression_aux -> ao conc expression_aux .)


state 149

    (62) block -> LBRACKET more_statement . RBRACKET

    RBRACKET        shift and go to state 154


state 150

    (51) condition -> IF LPAR expression RPAR block else_posible .

    READ            reduce using rule 51 (condition -> IF LPAR expression RPAR block else_posible .)
    WRITE           reduce using rule 51 (condition -> IF LPAR expression RPAR block else_posible .)
    WHILE           reduce using rule 51 (condition -> IF LPAR expression RPAR block else_posible .)
    IF              reduce using rule 51 (condition -> IF LPAR expression RPAR block else_posible .)
    ID              reduce using rule 51 (condition -> IF LPAR expression RPAR block else_posible .)
    RETURN          reduce using rule 51 (condition -> IF LPAR expression RPAR block else_posible .)
    RBRACKET        reduce using rule 51 (condition -> IF LPAR expression RPAR block else_posible .)


state 151

    (52) else_posible -> ELSE . block
    (62) block -> . LBRACKET more_statement RBRACKET

    LBRACKET        shift and go to state 134

    block                          shift and go to state 155

state 152

    (34) more_args -> COMMA var_type . ID to_args more_args

    ID              shift and go to state 156


state 153

    (37) func_block -> LBRACKET more_vars more_statement . optional_return RBRACKET
    (38) optional_return -> . RETURN exp SEMICOLON
    (39) optional_return -> .

    RETURN          shift and go to state 157
    RBRACKET        reduce using rule 39 (optional_return -> .)

    optional_return                shift and go to state 158

state 154

    (62) block -> LBRACKET more_statement RBRACKET .

    ELSE            reduce using rule 62 (block -> LBRACKET more_statement RBRACKET .)
    READ            reduce using rule 62 (block -> LBRACKET more_statement RBRACKET .)
    WRITE           reduce using rule 62 (block -> LBRACKET more_statement RBRACKET .)
    WHILE           reduce using rule 62 (block -> LBRACKET more_statement RBRACKET .)
    IF              reduce using rule 62 (block -> LBRACKET more_statement RBRACKET .)
    ID              reduce using rule 62 (block -> LBRACKET more_statement RBRACKET .)
    RBRACKET        reduce using rule 62 (block -> LBRACKET more_statement RBRACKET .)
    RETURN          reduce using rule 62 (block -> LBRACKET more_statement RBRACKET .)


state 155

    (52) else_posible -> ELSE block .

    READ            reduce using rule 52 (else_posible -> ELSE block .)
    WRITE           reduce using rule 52 (else_posible -> ELSE block .)
    WHILE           reduce using rule 52 (else_posible -> ELSE block .)
    IF              reduce using rule 52 (else_posible -> ELSE block .)
    ID              reduce using rule 52 (else_posible -> ELSE block .)
    RBRACKET        reduce using rule 52 (else_posible -> ELSE block .)
    RETURN          reduce using rule 52 (else_posible -> ELSE block .)


state 156

    (34) more_args -> COMMA var_type ID . to_args more_args
    (36) to_args -> .

    COMMA           reduce using rule 36 (to_args -> .)
    RPAR            reduce using rule 36 (to_args -> .)

    to_args                        shift and go to state 159

state 157

    (38) optional_return -> RETURN . exp SEMICOLON
    (71) exp -> . term exp_aux
    (74) term -> . factor term_aux
    (77) factor -> . LPAR expression RPAR
    (78) factor -> . var_cte
    (16) var_cte -> . CTEINT
    (17) var_cte -> . CTEDOUBLE
    (18) var_cte -> . CTEBOOL
    (19) var_cte -> . ID arr
    (20) var_cte -> . func_call
    (57) func_call -> . ID LPAR params RPAR

    LPAR            shift and go to state 74
    CTEINT          shift and go to state 40
    CTEDOUBLE       shift and go to state 37
    CTEBOOL         shift and go to state 39
    ID              shift and go to state 42

    func_call                      shift and go to state 38
    term                           shift and go to state 75
    var_cte                        shift and go to state 79
    exp                            shift and go to state 160
    factor                         shift and go to state 78

state 158

    (37) func_block -> LBRACKET more_vars more_statement optional_return . RBRACKET

    RBRACKET        shift and go to state 161


state 159

    (34) more_args -> COMMA var_type ID to_args . more_args
    (34) more_args -> . COMMA var_type ID to_args more_args
    (35) more_args -> .

    COMMA           shift and go to state 141
    RPAR            reduce using rule 35 (more_args -> .)

    more_args                      shift and go to state 162

state 160

    (38) optional_return -> RETURN exp . SEMICOLON

    SEMICOLON       shift and go to state 163


state 161

    (37) func_block -> LBRACKET more_vars more_statement optional_return RBRACKET .

    FUNC            reduce using rule 37 (func_block -> LBRACKET more_vars more_statement optional_return RBRACKET .)
    MAIN            reduce using rule 37 (func_block -> LBRACKET more_vars more_statement optional_return RBRACKET .)


state 162

    (34) more_args -> COMMA var_type ID to_args more_args .

    RPAR            reduce using rule 34 (more_args -> COMMA var_type ID to_args more_args .)


state 163

    (38) optional_return -> RETURN exp SEMICOLON .

    RBRACKET        reduce using rule 38 (optional_return -> RETURN exp SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 120 resolved using rule (var_cte -> func_call)
WARNING: rejected rule (assign -> func_call) in state 120
WARNING: Rule (assign -> func_call) is never reduced
